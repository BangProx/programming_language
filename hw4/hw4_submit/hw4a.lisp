;기본 아이디어는 한 열에는 퀸을 하나만 놓을 수 있다는 아이디어이다. 그리고 퀸이 이미 존재하는 열에는 퀸을 놓을 수 없다.
;따라서 열마다 퀸을 놓을 자리를 리스트로 만들면 행(칼럼)의 인덱스를 값으로 가진 일차원 배열로 퀸의 자리를 나타낼 수 있다.
;이후 퀸이 자리를 찾을 수 있는지 판단하는 함수를 구현한다. 그리고 자리를 찾을 수 없으면 거기까지만 탐색하고 
;찾을 수 있을때만 탐색을 진행한다. 즉, 첫번째 열부터 마지막 열까지 퀸이 들어갈 행을 일차원 리스트에 저장한다.

(format t "n-queen 문제입니다. n을 설정해주세요>>") ; n값을 입력받는다.
(let ((n (parse-integer (read-line)))) ; 입력받은 값을 정수로 변환해준후 n에 저장한다.
  (let ((row (make-list n :initial-element 0))) ; 퀸들의 위치를 저장하는 길이가 n인 리스트 생성하고 0으로 초기화한다. 
    (defun promising (x) ; 현재 열에서 유효한 위치인지 확인하는 함수이고, x는 현재 퀸이 배치된 열의 인덱스이다. 
      (loop for i from 0 below x  ;0~x-1까지는 퀸이 존재하므로 이러한 열들과 지금 고려하는 열이랑 충돌만 판단. 
            always (not (or (= (nth x row) (nth i row)) ; 같은 행에 위치한 퀸이 있는지 확인
                            (= (abs (- (nth x row) (nth i row))) (- x i)))))) ; 대각선에 위치한 퀸이 있는지 확인

    (defun nqueen (x)
      ; 퀸 배치 함수
      (if (= x n); 모든 퀸이 배치된 경우 즉, 탐색이 완료된 경우이다.
          (progn
            (print row) ; 해당 로우를 출력한다. 즉, n-queen 문제의 해답이다.
            (return-from nqueen)) ;nqueen 함수에서 탈출한다.
          (loop for i from 0 below n  ;아직 탐색중인 경우 반복문을 진행한다.
                do (progn             
                     (setf (nth x row) i) ; 현재 열에 퀸 배치한다. x는 열(칼럼) 값이다. 
                    ;즉, [x,i]에 퀸을 놓는다. 만약 성립 안하면 그 다음 i가 row[x]에 덮어씌워진다.리스트의 요소에 값을 할당하기 위해 setf를 사용했다.
                     (when (promising x) ; 유효한 위치인지 확인한다. 놓을 자리 있는지 판단하고 있으면 진행하고 없으면 다음 i로 넘어간다. 
                                         ;어차피 한 열에 한 자리만 가능하다. 따라서, 자리 찾으면 나가도 된다.
                       (nqueen (1+ x))))))) ;다음 열에 퀸 놓을자리 판단하러 진행한다.

    (nqueen 0) ; 퀸을 놓을 자리 탐색을 시작한다.
    ))
