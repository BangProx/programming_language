#기본 아이디어는 한 열에는 퀸을 하나만 놓을 수 있다는 아이디어이다. 그리고 퀸이 이미 존재하는 열에는 퀸을 놓을 수 없다.
#따라서 열마다 퀸을 놓을 자리를 리스트로 만들면 행(칼럼)의 인덱스를 값으로 가진 일차원 배열로 퀸의 자리를 나타낼 수 있다.
#이후 퀸이 자리를 찾을 수 있는지 판단하는 함수를 구현한다. 그리고 자리를 찾을 수 없으면 거기까지만 탐색하고 
#찾을 수 있을때만 탐색을 진행한다. 즉, 첫번째 열부터 마지막 열까지 퀸이 들어갈 행을 일차원 리스트에 저장한다.

n = int(input('n-queen 문제입니다. n을 설정해주세요>>'))
row = [0] * n   #길이가 n인 0으로 초기화한 리스트. 리스트에서 'x값' 번째에 y값을 저장하고있다. 
#row[i] = j 일때 (i,j)라고 생각하면 편하다. "i번째 열, 행은 j이다" 라고 생각하면 된다.
def promising(x):                                                   #x는 현재 퀸이 배치된 열의 인덱스이다. 
    for i in range(x):                                              #즉, 0~x-1까지는 퀸이 존재하므로 이러한 열들과 지금 고려하는 열이랑 충돌만 판단.                                  
        if row[x] == row[i] or abs(row[x] - row[i]) == abs(x - i):  #같은 행이거나 대각에 위치할때
            return False                                            #False 반환
    return True                                                     #처음이랑 놓을 자리가 있을때 True 반환

def nqueen(x):
    if x==n:#끝까지 탐색 완료
        print(row)#해당 로우 출력
        return
    else:
        for i in range(n):#몇번째 row에 퀸 놓을 수 있는지 찾을때까지 반복.
            #x는 열(칼럼) 값이다. 즉, [x,i]에 퀸을 놓는다. 만약 성립 안하면 그 다음 i가 row[x]에 덮어씌워진다. 
            row[x] = i
            if promising(x):#놓을 자리 있는지 판단. 있으면 진행 없으면 다음 i. 어차피 한 열에 한 자리만 가능하다. 따라서, 자리 찾으면 나가도 된다.
                nqueen(x+1) #다음 열에 퀸 놓을자리 판단하러 진행.
    
nqueen(0)   #퀸을 놓을 자리 탐색을 시작한다.
